<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python数字类型]]></title>
    <url>%2F6207104e%2F</url>
    <content type="text"><![CDATA[Python数字其他类型一样，也是一个对象。python数字是不可变的对象，所以它得值如果变了，那就会重新创建一个对象。一般将一个数值赋值给一个变量，那这个变量就是一个数字对象。。 Python中的数字类型Python数字一共有4种数据类型：整数int、长整数long（3.x之后废弃，用int代替）、浮点数float、复数complex。 Int类型一般叫整型、整数，正整数、负整数，不带小数点。3.x后没有限制大小的，可以当作2.x种得长整数用。 1234&gt;&gt;&gt; test = 2019&gt;&gt;&gt; type(test)&lt;class 'int'&gt;&gt;&gt;&gt; Long类型很长很长得整数。。过。 Float类型浮点型，浮点数。由整数和小数组成，跟其他语言一样。 1234&gt;&gt;&gt; test = 2019.07&gt;&gt;&gt; type(test)&lt;class 'float'&gt;&gt;&gt;&gt; Complex类型也叫复数，在编程里面还是第一次见到。。。基本概念与数学里面得复数类似：由实数(real)和虚数(imag)组成得数称为复数，基本语法：real+imagJ。有几个注意得地方：1、实数和虚数都是浮点行2、虚数后面必须带J或者j3、如果只写虚数，它前面会默认存在一个0.0得实数，也就是复数必须是由实数+虚数组成。 123456789101112131415161718192021222324252627282930313233343536&gt;&gt;&gt; test = 2J&gt;&gt;&gt; type(test)&lt;class 'complex'&gt;&gt;&gt;&gt; test.real0.0&gt;&gt;&gt; test.imag2.0&gt;&gt;&gt; test = 2J+3&gt;&gt;&gt; type(test)&lt;class 'complex'&gt;&gt;&gt;&gt; test.real3.0&gt;&gt;&gt; test.imag2.0&gt;&gt;&gt; test = 1+2J+3&gt;&gt;&gt; type(test)&lt;class 'complex'&gt;&gt;&gt;&gt; test.real4.0&gt;&gt;&gt; test.imag2.0&gt;&gt;&gt; test = 1+2+3J&gt;&gt;&gt; type(test)&lt;class 'complex'&gt;&gt;&gt;&gt; test.real3.0&gt;&gt;&gt; test.imag3.0&gt;&gt;&gt; test = 1+2J+3J&gt;&gt;&gt; type(test)&lt;class 'complex'&gt;&gt;&gt;&gt; test.real1.0&gt;&gt;&gt; test.imag5.0&gt;&gt;&gt; 数字类型就到这，总结一下要点1、3.x中整数不限制大小，浮点数限制到小数点后面15位。2、我们通常用得是基于10进制数字系统得数字，如果要使用二进制，8进制时需要进行转换： 进制 前缀 Base 二进制 ‘0b’ or ‘0B’ Base-2 八进制 ‘0o’或’0O’ Base-8 十六进制 ‘0x’ or ‘0X’ Base-16 栗子： 123456789101112131415161718192021222324252627&gt;&gt;&gt; test = 0b001&gt;&gt;&gt; print(test)1&gt;&gt;&gt; test = 0b010&gt;&gt;&gt; print(test)2&gt;&gt;&gt; test = 0b011&gt;&gt;&gt; print(test)3&gt;&gt;&gt; test = 0b100&gt;&gt;&gt; print(test)4&gt;&gt;&gt; test = 0b101&gt;&gt;&gt; print(test)5&gt;&gt;&gt; test = 0b110&gt;&gt;&gt; print(test)6&gt;&gt;&gt; test = 0b111&gt;&gt;&gt; print(test)7&gt;&gt;&gt; test = 0b001+0x001+0o002&gt;&gt;&gt; print(type(test))&lt;class 'int'&gt;&gt;&gt;&gt; print(test)4&gt;&gt;&gt; 3、3.x种整数做除法运算时，返回得是浮点型，而2.x种返回得是整型。 Python中得类型转换1234567891011&gt;&gt;&gt; 1+2.73.7&gt;&gt;&gt; 1+23&gt;&gt;&gt; int(1) + int(2.7)3&gt;&gt;&gt; float(1) + 2.73.7&gt;&gt;&gt; 2.0+complex(1+2J)(3+2j)&gt;&gt;&gt; 1、在加减运算中，只要出现浮点数，则结果必须是浮点数1.0+2.7 = 3.72、如果将浮点数强制转换，运算时，会去小数点前面得数字进行运算1+2=33、复数不可转为整数、浮点数 Python数学计算Python共开了一些内置方法来进行数学计算。玩几个 123456789101112131415&gt;&gt;&gt; import math&gt;&gt;&gt; test = 3.7&gt;&gt;&gt; print(math.ceil(test))4&gt;&gt;&gt; test = 3.2&gt;&gt;&gt; print(math.ceil(test))4&gt;&gt;&gt; test = 3.7 + 3&gt;&gt;&gt; print(math.ceil(test)) 7&gt;&gt;&gt; 10/71.4285714285714286&gt;&gt;&gt; math.ceil(10/7)2&gt;&gt;&gt; #可以看出，ceil得结果是大于test得正整数，与PHP不一样哦。 12345&gt;&gt;&gt; math.pow(2,3)8.0&gt;&gt;&gt; math.pow(2,10) #求2得10次方。1024.0&gt;&gt;&gt;]]></content>
      <tags>
        <tag>Python</tag>
        <tag>数字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串]]></title>
    <url>%2F5fea1e5a%2F</url>
    <content type="text"><![CDATA[上篇文章粗略的学习了一下Python的数据类型，感觉还是好生疏，所以决定细化学习一哈。。基础打不好，赶脚到后面更懵圈。。。今天的主题就是字符串。 在Python中创建字符串字符串的定义：用引号括起来起的字符就是字符串。 12345678910111213141516171819202122teemitop@DESKTOP-DG4M5KS MINGW64 /d/python$ pythonPython 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; str = 'hi,python'&gt;&gt;&gt; print(str)hi,python&gt;&gt;&gt; str = "hi,python"&gt;&gt;&gt; print(str)hi,python&gt;&gt;&gt; str = """hi,python"""&gt;&gt;&gt; print(str)hi,python&gt;&gt;&gt; str = """hi,python #三个引号可以将字符串标记成多行字符串... ,create python str... end"""&gt;&gt;&gt; print(str)hi,python,create python strend&gt;&gt;&gt; Python也可以替换字符串replace() 语法：目标字符串.replace(“替换谁”,”替换的新值”)12345678910&gt;&gt;&gt; print(str)hi,python,create python strend&gt;&gt;&gt; new_str = str.replace('python','php')&gt;&gt;&gt; print(new_str)hi,php,create php strend&gt;&gt;&gt; Python中的索引和分割字符串12345678&gt;&gt;&gt; test = 'hello,python'&gt;&gt;&gt; print(test[0])h&gt;&gt;&gt; print(test[3])l&gt;&gt;&gt; print(test[-4])t&gt;&gt;&gt; 很有意思，字符串有点像数组的下标，可以根据下标获取某个位置对应的字符串。 既然字符串有了下标，那就可以根据下标进行分割字符串，Python中用冒号：来分割字符串。 语法：字符串[a:b] a:开始位置，b:结束位置1234567891011121314151617&gt;&gt;&gt; test = 'hello,python'&gt;&gt;&gt; print(test[0:1])h&gt;&gt;&gt; print(test[0:5])hello&gt;&gt;&gt; print(test[0:02]) File "&lt;stdin&gt;", line 1 print(test[0:02]) ^SyntaxError: invalid token&gt;&gt;&gt; print(test[0:-2])hello,pyth&gt;&gt;&gt; print(test[2:-2])llo,pyth&gt;&gt;&gt; print(test[2:2])&gt;&gt;&gt; Python中修改/删除字符串1234567891011&gt;&gt;&gt; test = 'hello,python'&gt;&gt;&gt; test[1] = 'xxx'Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'str' object does not support item assignment&gt;&gt;&gt; print(test)hello,python&gt;&gt;&gt; test = 'hello,php'&gt;&gt;&gt; print(test)hello,php&gt;&gt;&gt; 从上面的错误提示看出，对象不支持分配，但是可以覆盖一个新的字符串。 123456789101112&gt;&gt;&gt; print(test)hello,php&gt;&gt;&gt; del test[1]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'str' object doesn't support item deletion&gt;&gt;&gt; del test&gt;&gt;&gt; print(test)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'test' is not defined&gt;&gt;&gt; 同样，也不能根据下标删除字符串中的某个字符，但是他可以销毁一个字符串变量。 Python中的字符串运算符加号: 字符串拼接，和js一样。 12345&gt;&gt;&gt; test = 'hello'&gt;&gt;&gt; test1 = ' python'&gt;&gt;&gt; print(test+test1)hello python&gt;&gt;&gt; 乘号 ：字符串重复赋值 1234&gt;&gt;&gt; test = "x"&gt;&gt;&gt; print(test*2)xx&gt;&gt;&gt; in：如果指定字符出现在某个字符串内，则返回True，否则返回False。 123456&gt;&gt;&gt; test = 'abcdef'&gt;&gt;&gt; print('a' in test)True&gt;&gt;&gt; print('g' in test)False&gt;&gt;&gt; not in: 和上面相反。 123456&gt;&gt;&gt; test = 'abcdef'&gt;&gt;&gt; print('g' not in test)True&gt;&gt;&gt; print('a' not in test)False&gt;&gt;&gt; for：遍历字符串。 12345678910&gt;&gt;&gt; test = 'abcdef'&gt;&gt;&gt; for i in test: print (i, end ="\n")...abcdef&gt;&gt;&gt; 字符串的转义可以用r或者R。 12345678&gt;&gt;&gt; print('\n')&gt;&gt;&gt; print(r'\n')\n&gt;&gt;&gt; print(R'\n')\n&gt;&gt;&gt; python中的字符串转义其实就是字符串的转义，为什么要转义，在平时的编码中有时候代码中必须要出现特定的运算符，但是在代码编译的时候，他把这个运算符当作了程序中的一部分来值行，导致程序报错，或者未达到预期想要的结果。。 123456789&gt;&gt;&gt; test = "abcdef"abc is a string"" File "&lt;stdin&gt;", line 1 test = "abcdef"abc is a string"" ^SyntaxError: invalid syntax&gt;&gt;&gt; test = "abcdef\"abc is a string\""&gt;&gt;&gt; print(test)abcdef"abc is a string"&gt;&gt;&gt; 转义符列表 字符串的格式化为了能格式化字符串，利用“%”来格式化，这个貌似都是通用的。 1234&gt;&gt;&gt; print(&apos;name:%s\nversion:%s&apos;%(&apos;python&apos;,&apos;3.7.3&apos;))name:pythonversion:3.7.3&gt;&gt;&gt; 格式符号列表 Python内置字符串函数1、capitalize() 返回首字符大写的字符串，小写的其余字符。1234&gt;&gt;&gt; test = 'abcd'&gt;&gt;&gt; print(test.capitalize())Abcd&gt;&gt;&gt; 2、lower() 将所有字符串转为小写。1234&gt;&gt;&gt; test = 'AbcdEFG'&gt;&gt;&gt; print(test.lower())abcdefg&gt;&gt;&gt; 3、upper() 将所有字符转为大写。1234&gt;&gt;&gt; test = 'AbcdEFG'&gt;&gt;&gt; print(test.upper())ABCDEFG&gt;&gt;&gt; 4、swapcase() 将字符串中的大小写互转 大-&gt;小 、 小-&gt;大1234&gt;&gt;&gt; test = 'AbcdEFG'&gt;&gt;&gt; print(test.swapcase())aBCDefg&gt;&gt;&gt; 5、title() 将每个单词的首字母大写。1234&gt;&gt;&gt; test = 'AbcdEFG opp'&gt;&gt;&gt; print(test.title())Abcdefg Opp&gt;&gt;&gt; 6、count(str[, beg [, end]]) 统计某个字符在字符串中出现的次数，区分大小写，可限制范围。1234567891011121314151617&gt;&gt;&gt; test = 'AbcdEFG opp'&gt;&gt;&gt; print(test.count('a'))0&gt;&gt;&gt; print(test.count('A'))1&gt;&gt;&gt; print(test.count('A',0,2))1&gt;&gt;&gt; test = 'AbcAAdEFG opp'&gt;&gt;&gt; print(test.count('A',0,2))1&gt;&gt;&gt; print(test.count('A',0,3))1&gt;&gt;&gt; print(test.count('A',0,6))3&gt;&gt;&gt; print(test.count('A',0,4))2&gt;&gt;&gt; 7、islower() 如果字符串中都是小写返回True,否则返回False。1234567&gt;&gt;&gt; test = 'AbcAAdEFG opp'&gt;&gt;&gt; print(test.islower())False&gt;&gt;&gt; test = 'opp'&gt;&gt;&gt; print(test.islower())True&gt;&gt;&gt; 8、isupper() 如果字符串中都是大写返回True,否则返回False。1234567&gt;&gt;&gt; test = 'AbcAAdEFG opp'&gt;&gt;&gt; print(test.isupper())False&gt;&gt;&gt; test = 'OOP'&gt;&gt;&gt; print(test.isupper())True&gt;&gt;&gt; 9、isdecimal() 如果所有字符都是十进制，则返回True,否则返回False。123456789101112&gt;&gt;&gt; test = u'xx'&gt;&gt;&gt; print(test.isdecimal())False&gt;&gt;&gt; test = 2019&gt;&gt;&gt; print(test.isdecimal())Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'int' object has no attribute 'isdecimal'&gt;&gt;&gt; test = '2019'&gt;&gt;&gt; print(test.isdecimal())True&gt;&gt;&gt; 10、isdigit() 如果字符串内只有数字返回True,反则返回False。1234567&gt;&gt;&gt; test = '2019'&gt;&gt;&gt; print(test.isdigit())True&gt;&gt;&gt; test = '2019年了啊'&gt;&gt;&gt; print(test.isdigit())False&gt;&gt;&gt; 11、isnumeric() 如果字符串内只有数字返回True,反则返回False 只针对unicode对象上。12345678910&gt;&gt;&gt; test = '2019'&gt;&gt;&gt; print(test.isnumeric())True&gt;&gt;&gt; test = u'2019'&gt;&gt;&gt; print(test.isnumeric())True&gt;&gt;&gt; test = u'2019年了啊'&gt;&gt;&gt; print(test.isnumeric())False&gt;&gt;&gt; 12、isalpha() 如果一个非空字符串只包含字母返回True,否则返回False。12345678910&gt;&gt;&gt; test = 'python'&gt;&gt;&gt; print(test.isalpha())True&gt;&gt;&gt; test = ''&gt;&gt;&gt; print(test.isalpha())False&gt;&gt;&gt; test = 'python3.7.3'&gt;&gt;&gt; print(test.isalpha())False&gt;&gt;&gt; 13、isalnum() 如果一个非空字符串只包含十进制数字或者字母返回True,否则返回False。12345678910&gt;&gt;&gt; test = 'python'&gt;&gt;&gt; print(test.isalnum())True&gt;&gt;&gt; test = 'python3'&gt;&gt;&gt; print(test.isalnum())True&gt;&gt;&gt; test = 'python3.7.3'&gt;&gt;&gt; print(test.isalnum())False&gt;&gt;&gt; 14、rjust() 返回一个补充过的字符串，右对齐，第一个参数是新字符串的长度，第二个参数是用什么补全剩余字符串，默认位空格。1234567&gt;&gt;&gt; print(test)python&gt;&gt;&gt; print(test.rjust(10,'a'))aaaapython&gt;&gt;&gt; print(test.rjust(10,'-'))----python&gt;&gt;&gt; 15、ljust() 和一样，顺序相反。1234567&gt;&gt;&gt; print(test)python&gt;&gt;&gt; print(test.ljust(10,'a'))pythonaaaa&gt;&gt;&gt; print(test.ljust(10,'-'))python----&gt;&gt;&gt; 16、center() 和上面一样，只不过将原始字符串居中，从两边进行补全，奇数时优先左边补全。123456789&gt;&gt;&gt; print(test)python&gt;&gt;&gt; print(test.center(10,'-'))--python--&gt;&gt;&gt; print(test.center(10,'a'))aapythonaa&gt;&gt;&gt; print(test.center(11,'a'))aaapythonaa&gt;&gt;&gt; 17、zfill() 也是补全，只不过用0代替。注：如果字符串前面存在特殊字符，则从特殊字符前面补齐。1234567891011121314&gt;&gt;&gt; print(test)python&gt;&gt;&gt; print(test.zfill(10))0000python&gt;&gt;&gt; test = '/python'&gt;&gt;&gt; print(test.zfill(10))000/python&gt;&gt;&gt; test = '*python'&gt;&gt;&gt; print(test.zfill(10))000*python&gt;&gt;&gt; test = '#python'&gt;&gt;&gt; print(test.zfill(10))000#python&gt;&gt;&gt; 18、find(str [，i [，j]]) 查找字符串，从i开始，到j结束，返回该字符串的下标，如果未找到则返回-1。12345678910&gt;&gt;&gt; test = 'python'&gt;&gt;&gt; print(test)python&gt;&gt;&gt; print(test.find('t'))2&gt;&gt;&gt; print(test.find('t',2,4))2&gt;&gt;&gt; print(test.find('t',3,4))-1&gt;&gt;&gt; 19、index(str[,i [,j]]) 与find()相同，唯一区别，如果未查找到指定的字符串就会报错。12345678910&gt;&gt;&gt; test = 'python'&gt;&gt;&gt; print(test.index('p'))0&gt;&gt;&gt; print(test.index('p',1,3))Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: substring not found&gt;&gt;&gt; print(test.index('p',0,3))0&gt;&gt;&gt; 20、rfind(str[,i [,j]]) 与find()相同,只是返回找到子字符串的最后一个索引。123456&gt;&gt;&gt; test = 'python'&gt;&gt;&gt; print(test.rfind('t',0,10))2&gt;&gt;&gt; print(test.rfind('t',10))-1&gt;&gt;&gt; 21、split([sep[,maxsplit]]) 将字符串分割成列表，默认分隔符未空格。1234&gt;&gt;&gt; test = 'python is a good language'&gt;&gt;&gt; print(test.split())['python', 'is', 'a', 'good', 'language']&gt;&gt;&gt; 22、splitlines(num) 将字符串分割成列表，是从换行符出现的位置进行分割，如果num存在，则在列表中存在换行符。12345678910111213141516&gt;&gt;&gt; test = 'python is\n a good\n language'&gt;&gt;&gt; print(test)python is a good language&gt;&gt;&gt; print(test.splitlines())['python is', ' a good', ' language']&gt;&gt;&gt; print(test.splitlines(1))['python is\n', ' a good\n', ' language']&gt;&gt;&gt; print(test.splitlines(2))['python is\n', ' a good\n', ' language']&gt;&gt;&gt; print(test.splitlines(-1))['python is\n', ' a good\n', ' language']&gt;&gt;&gt; print(test.splitlines(0))['python is', ' a good', ' language']&gt;&gt;&gt; 23、join(seq) 字符串连接。123456&gt;&gt;&gt; test = 'python is\n a good\n language'&gt;&gt;&gt; print('-'.join(test))p-y-t-h-o-n- -i-s-- -a- -g-o-o-d-- -l-a-n-g-u-a-g-e&gt;&gt;&gt; 24、lstrip([chars]) 删除指定的字符（只能是开头的），并返删除后的字符串。12345678910&gt;&gt;&gt; test = 'python is a good language'&gt;&gt;&gt; print(test)python is a good language&gt;&gt;&gt; print(test.lstrip())python is a good language&gt;&gt;&gt; print(test.lstrip('t'))python is a good language&gt;&gt;&gt; print(test.lstrip('p'))ython is a good language&gt;&gt;&gt; 25、rstrip() 与上面相反。1234567891011121314151617&gt;&gt;&gt; print(test)python is a good language&gt;&gt;&gt; print(test.rstrip())python is a good language&gt;&gt;&gt; print(test.rstrip(eg))Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'eg' is not defined&gt;&gt;&gt; print(test.rstrip(e))Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'e' is not defined&gt;&gt;&gt; print(test.rstrip('eg'))python is a good langua&gt;&gt;&gt; print(test.rstrip('g'))python is a good language&gt;&gt;&gt; 26、rindex(str[,i [,j]]) 从目标字符串中搜索指定的字符，返回该下标，如果没找到则会报错。1234567891011&gt;&gt;&gt; print(test)python is a good language&gt;&gt;&gt; print(test.rindex('p',0,2))0&gt;&gt;&gt; print(test.rindex('is',0,2))Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: substring not found&gt;&gt;&gt; print(test.rindex('is',0,10))7&gt;&gt;&gt; 27、len() 返回目标字符串的长度。12345&gt;&gt;&gt; print(test)python is a good language&gt;&gt;&gt; print(len(test))25&gt;&gt;&gt; 就到这里吧，后面在遇到会整理到这块儿。 总结：感觉好多方法与js类似，也有很多方法赶脚没啥用，整体来说还不错。。。吃饭吃饭。饿死了。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据类型]]></title>
    <url>%2F9f07ae5c%2F</url>
    <content type="text"><![CDATA[周五了鸭~ 鲁鲁约起来哈哈哈哈哈哈哈哈…… Python数据类型的定义和其他语言都一样，都是来规范一个数据的的上限和下限。不同的是在Python中，是根据语法来断定一个数据的数据类型。。比如用整型就是非十进制的数字，带小数点的就为浮点型，字符串就是用引号括起来的，好像和拍黄片差不多哦。。分别学习一下吧！ 布尔型(Booleans)几乎每种语言都有布尔型，也基本都是true、false用法也雷同。真即为True，也可以是1，假即为False同样也可以是0。神奇的是True、False也可以参与运算。。。 12345test = True;if test: # 也可以 test=True: print('结果为真')else: print('结果为假') 123teemitop@DESKTOP-DG4M5KS MINGW64 /d/python$ python type.py结果为真 12345678910&gt;&gt;&gt; test = 2+True&gt;&gt;&gt; print(test)3&gt;&gt;&gt; test = 0-True&gt;&gt;&gt; print(test)-1&gt;&gt;&gt; test = 1+True-False+1&gt;&gt;&gt; print(test)3&gt;&gt;&gt; 还可以使用type()来确定一个变量或值得数据类型。 1234567891011121314&gt;&gt;&gt; test = 2+True&gt;&gt;&gt; print(test)3&gt;&gt;&gt; test = 0-True&gt;&gt;&gt; print(test)-1&gt;&gt;&gt; test = 1+True-False+1&gt;&gt;&gt; print(test)3&gt;&gt;&gt; print(type(test))&lt;class 'int'&gt; #整型&gt;&gt;&gt; test = True&gt;&gt;&gt; print(type(test))&lt;class 'bool'&gt; #布尔型 数字(Numbers)Pyhton中将整型、浮点型、以及另外一个complex数字类型统称为数字类型。 12345678910111213&lt;class 'int'&gt;&gt;&gt;&gt; test = 3&gt;&gt;&gt; print(type(test))&lt;class 'int'&gt;&gt;&gt;&gt; test = 3.0&gt;&gt;&gt; print(type(test))&lt;class 'float'&gt;&gt;&gt;&gt; test = 3+1J #在数字后面加KJ或者小写j就可以让这个变量得数据类型变为complex类型&gt;&gt;&gt; print(type(test))&lt;class 'complex'&gt;&gt;&gt;&gt; print(isinstance(test,complex))True&gt;&gt;&gt; 可以用内置isinstance()方法检测对象的数据类型isinstance() 方法的语法: 1isinstance(object, class) object - 实例对象 class - 类名、基本类型等 object的类型与class的参数类型一致，则返回True，否则返回False。 123456&gt;&gt;&gt; test = 3&gt;&gt;&gt; isinstance(test,int)True&gt;&gt;&gt; isinstance(test,str)False&gt;&gt;&gt; 此外，整型是没有大小限制的，浮点型是小数点后面最多跟15位数，这就不试了。 字符串(Strings)被引号括起来的基本都称为字符串。Python中字符串也可以是多行字符串，类似PHP中的字符串拼接吧 123456&gt;&gt;&gt; test = """这是一个字符串... 但是，字符串还可以是多行字符串... 还没结束... """&gt;&gt;&gt; type(test)&lt;class 'str'&gt; 字符串是不可变的，所以变量在赋值之后，内存将重新分配并使用。 1234567&gt;&gt;&gt; test = 3&gt;&gt;&gt; id(test)1770939520&gt;&gt;&gt; demo = test&gt;&gt;&gt; id(demo)1770939520&gt;&gt;&gt; 两个内存地址都为1770939520。 字节(Bytes)字节是Python中的不可变类型。它可以存储一个字节序列（每个8位），范围从0到255。与数组类似，可以使用下标获取对应的值。字节和字符串的区别： 字节对象是一个字节序列，而字符串是存储字符序列。 字节是机器读的，字符串我们可以看得见的。 字节是存在电脑的磁盘中的，而字符串要写入磁盘需要先编码。 123456&gt;&gt;&gt; test = bytes(16)&gt;&gt;&gt; print(type(test))&lt;class 'bytes'&gt; #字节类型&gt;&gt;&gt; print(test)b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' #字节序列&gt;&gt;&gt; 列表(Lists)Python列表是一个类似于构造的数组，它以有序的顺序存储任意类型的对象,索引也是和数组一样从0开始。 123456789101112&gt;&gt;&gt; test = ['abc',123,True,&#123;'a','b'&#125;] #和php一样啊&gt;&gt;&gt; print(type(test))&lt;class 'list'&gt;&gt;&gt;&gt; print(test[0]) #这也一样abc&gt;&gt;&gt; print(test[2])True&gt;&gt;&gt; print(type(test[2]))&lt;class 'bool'&gt;&gt;&gt;&gt; print(type(test[3]))&lt;class 'set'&gt;&gt;&gt;&gt; 列表里面的元素也是可变的 1234&gt;&gt;&gt; test[2] = 'edf'&gt;&gt;&gt; print(test)['abc', 123, 'edf', &#123;'b', 'a'&#125;]&gt;&gt;&gt; list也可以是多个集合，类似二维数组或者多维。。 1234&gt;&gt;&gt; test = [1,2,3,[2,3,4],[4,5,6]]&gt;&gt;&gt; print(test)[1, 2, 3, [2, 3, 4], [4, 5, 6]]&gt;&gt;&gt; 切片列表，就是列表中提取一个元素或一堆元素。类似截取数组中的元素。 12345678&gt;&gt;&gt; print(test)[1, 2, 3, [2, 3, 4], [4, 5, 6, [7, 8]]]&gt;&gt;&gt; print(test[0:1])[1]&gt;&gt;&gt; print(test[0:4])[1, 2, 3, [2, 3, 4]]&gt;&gt;&gt; print(test[1:2])[2] 元组(Tuples)元组是由逗号分隔的Python对象的异构集合。这意味着不同数据类型的对象可以在元组中共存。元组和列表有些相似。 两个对象都是有序序列。 它们可以实现索引和重复。 允许嵌套。 他们可以存储不同类型的值。 元组是用小括号来定义的，其中元素也是用逗号分隔。定义一个空的元组 123456&gt;&gt;&gt; test = ()&gt;&gt;&gt; print(test)()&gt;&gt;&gt; print(type(test))&lt;class 'tuple'&gt;&gt;&gt;&gt; 定义一个多集合的元组 123456&gt;&gt;&gt; test = (1,3,5,7,9)&gt;&gt;&gt; test1 = ('one','two','three','...')&gt;&gt;&gt; merge = (test,test1)&gt;&gt;&gt; print(merge)((1, 3, 5, 7, 9), ('one', 'two', 'three', '...'))&gt;&gt;&gt; 定义一个重复的元组 1234&gt;&gt;&gt; test = (1,2,3) * 2&gt;&gt;&gt; print(test)(1, 2, 3, 1, 2, 3)&gt;&gt;&gt; 元组中的切片 123456789101112&gt;&gt;&gt; test = (1,2,3) * 2&gt;&gt;&gt; print(test)(1, 2, 3, 1, 2, 3)&gt;&gt;&gt; print(test[1:])(2, 3, 1, 2, 3)&gt;&gt;&gt; print(test[::-1])(3, 2, 1, 3, 2, 1)&gt;&gt;&gt; print(test[:-1])(1, 2, 3, 1, 2)&gt;&gt;&gt; print(test[2:3])(3,)&gt;&gt;&gt; []里面的参数都是类似数组的下标，从0开始，截取的时候要注意。 元组与列表的不同元组与列表有所不同，因为它们是不可变的。Python不允许在创建元组后对其进行修改。我们以后不能添加或删除任何元素。相反，Python希望我们使用更新的元素序列创建一个新的元素。可变对象除外。 元组的意义吧 Python使用元组从函数返回多个值。 元组比列表更轻量级。 它作为一个容器来填充多个东西。 集合(Sets)在所有Python数据类型中，该集合是支持并集，交集，对称差异等数学运算的集合。集合是唯一且不可变对象的无序集合，用花括号{}定义，里面也是由逗号分隔。官方文档说，集合类型比列表具有显着优势。它实现了一种高度优化的方法，用于检查容器是否承载特定元素。这里使用的机制基于称为哈希表的数据结构。没看懂。。 集合的创建需要用内置函数set创建，有点实例化对象的赶脚。。 123456789101112&gt;&gt;&gt; test = set('什么是集合？')&gt;&gt;&gt; print(type(test))&lt;class 'set'&gt;&gt;&gt;&gt; print(test)&#123;'合', '集', '什', '？', '么', '是'&#125; #顺序都乱了？&gt;&gt;&gt;&gt;&gt;&gt; test = &#123;'集合是什么鬼？'&#125;&gt;&gt;&gt; print(type(test))&lt;class 'set'&gt;&gt;&gt;&gt; print(test)&#123;'集合是什么鬼？'&#125;&gt;&gt;&gt; 冰冻集合冰冻集合是不可变的，用frozenset()表示。 123456789&gt;&gt;&gt; frozenset()frozenset()&gt;&gt;&gt; test = &#123;'beijing','shanghai','tianjin'&#125;&gt;&gt;&gt; test = frozenset(test)&gt;&gt;&gt; print(type(test))&lt;class 'frozenset'&gt;&gt;&gt;&gt; print(test)frozenset(&#123;'tianjin', 'beijing', 'shanghai'&#125;)&gt;&gt;&gt; 正常集合与冰冻集合的差异 12345678910&gt;&gt;&gt; test = &#123;'beijing','shanghai','tianjin'&#125;&gt;&gt;&gt; print(test)&#123;'tianjin', 'beijing', 'shanghai'&#125;&gt;&gt;&gt; test.add('lundun')&gt;&gt;&gt; print(test)&#123;'tianjin', 'beijing', 'lundun', 'shanghai'&#125;&gt;&gt;&gt; demo = frozenset(['beijing','shanghai','tianjin'])&gt;&gt;&gt; print(demo)frozenset(&#123;'tianjin', 'beijing', 'shanghai'&#125;)&gt;&gt;&gt; 有点像元组，不能随意增减自身的元素，它内部的集合必须是冻结集合对象。 字典(Dictionaries)Python中的字典是键值对的无序集合，字典类型解决了有效存储大数据集的问题。 创建字典12345678&gt;&gt;&gt; test = &#123;'key':'value','name':'zhangsan','sex':18&#125;&gt;&gt;&gt; print(type(test))&lt;class 'dict'&gt;&gt;&gt;&gt; print(test)&#123;'key': 'value', 'name': 'zhangsan', 'sex': 18&#125; #json的赶脚或者类似php的序列化&gt;&gt;&gt; test['name'] #可以利用建来获取对应的值'zhangsan'&gt;&gt;&gt; 字典访问元素的方法 keys（） - 将键值区分，或者叫做获取字典的所有键。 values（） - 这个和上面相反，获取字典的所有值。 items（） -以（键，值）对的列表样式返回项目。 1234567&gt;&gt;&gt; test.keys()dict_keys(['key', 'name', 'sex'])&gt;&gt;&gt; test.values()dict_values(['value', 'zhangsan', 18])&gt;&gt;&gt; test.items()dict_items([('key', 'value'), ('name', 'zhangsan'), ('sex', 18)])&gt;&gt;&gt; 字典里面的对象是可变的，所以可以变化，这个语法好不习惯。。 12345678910&gt;&gt;&gt; test['like'] = 'english'&gt;&gt;&gt; print(test)&#123;'key': 'value', 'name': 'zhangsan', 'sex': 18, 'like': 'english'&#125;&gt;&gt;&gt; test.update(&#123;'name':'lisi'&#125;)&gt;&gt;&gt; print(test)&#123;'key': 'value', 'name': 'lisi', 'sex': 18, 'like': 'english'&#125;&gt;&gt;&gt; del test['key']&gt;&gt;&gt; print(test)&#123;'name': 'lisi', 'sex': 18, 'like': 'english'&#125;&gt;&gt;&gt;]]></content>
      <tags>
        <tag>Python</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python表达式、换行、缩进]]></title>
    <url>%2Fbbbf860f%2F</url>
    <content type="text"><![CDATA[表达式在PHP总的表达式：几乎所写的任何东西都是一个表达式。简单但却最精确的定义一个表达式的方式就是“任何有值的东西”。也就是说基本上所有元素都可以称为一个表达式了。。而在python中：可以求出某个值的语法单元。 换句话说，一个表达式就是表达元素例如字面值、名称、属性访问、运算符或函数调用的汇总，它们最终都会返回一个值。 与许多其他语言不同，并非所有语言构件都是表达式。 还存在不能被用作表达式的 statement，例如 while。 赋值也是属于语句而非表达式。 python表达式中的各种元素： 算术转换、 原子、原型、 await表达式、 幂运算符、 一元算术和位运算、 二元元运算符、 移位运算、 二元位运算、 布尔运算、 条件表达式、 lambda表达式、 表达式列表、 求值顺序、 运算符优先级 我的理解：一个表达式就是由各种元素组成，而它们最终都会返回一个值，所以一个值本身也就是一个表达式？有点蒙。。好，在了解下Python表达式张什么样： 12345678910teemitop@DESKTOP-DG4M5KS MINGW64 /d/python$ pythonPython 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; pow(2,3) #函数表达式8&gt;&gt;&gt; 100+200/100 #使用算术表达式102.0&gt;&gt;&gt; 多行语句换行python里面可以用\来将一个集合分割换行。它区分显式行和隐式行 显式：1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; test = [1,2,3\] #不可以在一行完整的表达室内换行 File "&lt;stdin&gt;", line 1 test = [1,2,3\] ^SyntaxError: unexpected character after line continuation character&gt;&gt;&gt; test = [1,2,3\ #不可以将一个元素拆分进行换行... 4\ File "&lt;stdin&gt;", line 2 4\ ^SyntaxError: invalid syntax&gt;&gt;&gt; test = [1,2,3\ #正确示例... ,4\... ,5,6,\... 7]&gt;&gt;&gt; print(test)[1, 2, 3, 4, 5, 6, 7]&gt;&gt;&gt;&gt;&gt;&gt; test = ['a',\... 'b','c',\... 'd',\... 'ef','g']&gt;&gt;&gt; print(test)['a', 'b', 'c', 'd', 'ef', 'g']&gt;&gt;&gt;&gt;&gt;&gt; test = 'abc\... ef\... ghijkl\... m'&gt;&gt;&gt; print(test)abcefghijklm&gt;&gt;&gt; 隐式用()、[]、{}括起来换行。 123456789101112131415161718192021&gt;&gt;&gt; test = (2+3 # test = 2+3-1/2+6... -1... /2... +6)&gt;&gt;&gt; print(test)10.5&gt;&gt;&gt;&gt;&gt;&gt; test = ['a'... ,'b','c',... 'd'... ,'ef']&gt;&gt;&gt; print(test)['a', 'b', 'c', 'd', 'ef']&gt;&gt;&gt;&gt;&gt;&gt; test = &#123;'a'... ,'b'... 'c','d'... ,'e',... 'f'&#125;&gt;&gt;&gt; print(test)&#123;'f', 'bc', 'd', 'e', 'a'&#125; 缩进前面提过缩进，今天看到了在学一遍把。python编程风格属实和其他语言有所不同，别人都是用{}来把代码圈起来，Python是用缩进的办法来标记代码块，而且缩进的空格数量是4个。 1234567891011&gt;&gt;&gt; def test_function():... name = input('同你，你叫啥？')... if name == 'python':... print('见到你很高兴',name)... else:... print('见到你好难过',name)... test_function() File "&lt;stdin&gt;", line 7 test_function() ^SyntaxError: invalid syntax #不知道是交互模式下tab缩进问题还是换行问题，还是其他原因，总之放弃在python交互模式下输出了 另外，矫正之前一个错误，退出交互模式exit()即可，不一定加分号。好，回到命令行，将上面的代码保存到.py文件，然后运行 123456teemitop@DESKTOP-DG4M5KS MINGW64 /d/python$ python hello.py同学，你叫什么？python见到你很高心， pythonteemitop@DESKTOP-DG4M5KS MINGW64 /d/python 附上代码： 12345678def demo_routine(): name = input('同学，你叫什么？') if name=='python': print('见到你很高心，',name) else: return Falsedemo_routine()]]></content>
      <tags>
        <tag>Python</tag>
        <tag>表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python关键字、标识符、变量]]></title>
    <url>%2F8029f1fe%2F</url>
    <content type="text"><![CDATA[关键字关键字的含义和其他语言都一样：具有特殊含义的特殊字。在python中，所有的关键字都要区分大小写，这一点真的好严谨哦。。 给test变量赋值一个为真的值： 12345&gt;&gt;&gt; test = True #程序未报错&gt;&gt;&gt; test = true #程序报错Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'true' is not defined 具体他的关键字都是咋写的，python有这么一个统计，在python交互模式下： 12345678910111213&gt;&gt;&gt; help("keywords")Here is a list of the Python keywords. Enter any keyword to get more help.False class from orNone continue global passTrue def if raiseand del import returnas elif in tryassert else is whileasync except lambda withawait finally nonlocal yieldbreak for not 也可以这样： 12345&gt;&gt;&gt; keyword.kwlist['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 如果官方的关键字有变动，去除或者新增，就从新导入即可：&gt;&gt;&gt; import keyword 标识符Python是用户自定义的名称，用来表示变量，函数，类，模块或任何其他对象。Python中标识符的规则：1、标识符的开头不能是数字 123456789101112teemitop@DESKTOP-DG4M5KS MINGW64 /d/python$ pythonPython 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; test=0&gt;&gt;&gt; 0test=0 File "&lt;stdin&gt;", line 1 0test=0 ^SyntaxError: invalid syntax&gt;&gt;&gt; 2、可以是大小写字母+数字+下划线,但是不能有特殊字符 12345678&gt;&gt;&gt; testTes99t_10_wwwZ=000&gt;&gt;&gt; print(testTes99t_10_wwwZ)0&gt;&gt;&gt;&gt;&gt;&gt; blog.slomoo.com@aliyun.com=666 File "&lt;stdin&gt;", line 1SyntaxError: can't assign to operator&gt;&gt;&gt; 3、关键字不能当作标识符 123456&gt;&gt;&gt; for=2 File "&lt;stdin&gt;", line 1 for=2 ^SyntaxError: invalid syntax&gt;&gt;&gt; Python有一个方法可以检测某个标识符是否正确或者说有效，正确返回true，错误返回false 1234&gt;&gt;&gt; 'blog.slomoo.com@aliyun.com'.isidentifier()False&gt;&gt;&gt; 'blog_666slomoo_com_aliyun_com'.isidentifier()True 变量Python中的变量表示一个实体，值可以像PHP的值一样，可以随意赋值，可以覆盖。Python中很奇怪哦，创建一个变量不叫声明，而是叫初始化，难道是因为它存在与内存的原因？ 123456&gt;&gt;&gt; test=0&gt;&gt;&gt; print(test)0&gt;&gt;&gt; test=22&gt;&gt;&gt; print(test)22 如果test不存在则创建，存在则会覆盖。小知识：id()可以查看这个变量在内存中的索引位置 1234567&gt;&gt;&gt; test=0&gt;&gt;&gt; id(test)269771856&gt;&gt;&gt; test=22&gt;&gt;&gt; id(test)269772208&gt;&gt;&gt; 另外，变量也可以是不同的数据类型 12345678910111213&gt;&gt;&gt; test=0&gt;&gt;&gt; type(test)&lt;class 'int'&gt;&gt;&gt;&gt; test='aaa'&gt;&gt;&gt; type(test)&lt;class 'str'&gt;&gt;&gt;&gt; test=2.3&gt;&gt;&gt; type(test)&lt;class 'float'&gt;&gt;&gt;&gt; test=&#123;'php'&#125;&gt;&gt;&gt; type(test)&lt;class 'set'&gt;&gt;&gt;&gt;]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,Python]]></title>
    <url>%2Fd6c50ec3%2F</url>
    <content type="text"><![CDATA[打卡今天编写第一个Python程序，首先应该知道Python可以是交互式编程（带&gt;&gt;&gt;），也可以是命令行运行.py文件，也就是脚本编程。 基本语法进到Python交互模式，命令行直接python回车： 123456teemitop@DESKTOP-DG4M5KS MINGW64 /d/python$ pythonPython 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; 1&gt;&gt;&gt; print("hello,python") 直接输出 1hello,python 上面的是在python交互模式下写的程序，还有一种就是将所写的代码放在python脚本内，然后命令行值行它。建立hello.py文件，将上面的代码保存，然后在命令行值行这个文件。 123teemitop@DESKTOP-DG4M5KS MINGW64 /d/python$ python hello.pyhello,python print() 可以输出任何东西，但如果想要输入，Python提供了一个方法 input(),输入input()并按下回车后，Python交互式命令行就在等待输入了。这时，输入任意字符，然后按回车后完成输入。 123&gt;&gt;&gt; input()test'test' 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量： 123name="zhangsan" #name就是一个字符串sex=18 #sex就是一个整型... 上面的代码为了好理解点，可以将它赋值给一个变量，即： 1234&gt;&gt;&gt; name = input("你叫什么？");print("hello",name) 回车你叫什么？Python输出：hello Python 同样，也可以将代码保存在Python脚本内运行。 总结：Python语法和其他语言都有很多的相似之处，比如变量命名，变量名必须是大小写英文、数字和_的组合，且不能用数字开头 1234Python：name = "xxxxx";PHP: $name = "xxxx";Java: String name="xxxx";.... 最大的区别就是Python的代码不会用{}标识，而是用缩进的方法来规范，而且这个缩进的大小也是相当严谨哦。。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习日记]]></title>
    <url>%2F7c404c2f%2F</url>
    <content type="text"><![CDATA[为什么要学习?听过这么一句话， 比你优秀的人不可怕，可怕的是比你优秀的人比你更努力。对我而言，这句话同样具有很大的杀伤力。因为不进步，就等于落后。 为什么选择python?火。 安装篇我安装的是目前最新版本Python 3.7.3，传送门，选择 Download Windows x86 executable installer大概25M左右。下载好之后就运行文件，需要勾选Add Python 3.7 to PATH，即配置环境变量，忘记勾选的话就需要手动去配置环境变量了，否则，从新安装即可。然后点“Install Now”即可完成安装。我建议在windows装个 git，不然后面用windows的命令提示符操作好变扭，反正我是用不惯。随便创建一个学习python用的文件夹 D:\python，在这个文件夹下面运行 Git Bash，然后运行 python –version 如果能显示python 版本号，即安装成功。 123teemitop@DESKTOP-DG4M5KS MINGW64 /d/python$ python --versionPython 3.7.3 然后在这块儿输出： 123teemitop@DESKTOP-DG4M5KS MINGW64 /d/python$ print("hello py")bash: syntax error near unexpected token `"hello py"' 报错，不能这么执行，原因，我们现在是在git的命令行模式，需要开启python的交互模式，如果在windows命令行： 1234C:\Users\teemitop&gt;pythonPython 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; 出现三个大于号，才进入python交互模式，如果用的是Git Bash，必须通过winpty python 或者python -i进入。如果嫌两个命令有点长，繁琐，可以给给它配置个别名：去D:\Program Files\Git\etc，自行查找，找到这个文件** bash.bashrc** 用编辑器打开，在文末加入 alias python=&#39;winpty python &#39;，然后重新打开 Git Bash，直接运行python 即可进入python交互模式 123456teemitop@DESKTOP-DG4M5KS MINGW64 /d/python$ pythonPython 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; 退出的时候直接X掉或者exit();后面的括号、分号都不能丢，好严谨哦。。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ocean 中文文档]]></title>
    <url>%2Fe3058817%2F</url>
    <content type="text"><![CDATA[Ocean 是基于 Hexo 默认主题 landscape 的功能，设计的一款支持移动设备的主题，并且集成了 Gitalk 评论功能。 由于我是一枚 Designer 而不是 Coder，所以 欢迎指正！ 如果你喜欢 Ocean 可以 点 这里下载，主题默认使用 Logo 是 Hexo 的 Logo，如果你也喜欢并且想使用我的这个 Shark（小鲨鱼）Logo 的话，那么希望你能给 Ocean 一个 Star，如果你还把页面底部 theme 的作者改为你自己的名字的话，那么更应该给 Ocean 一个 Star 了！ 这里 Clone 了 Markdown 的基本语法在 Ocean 中的展现形式，可能会让你更快速的认知到 Ocean 是否适合你的 Hexo ！ 安装$ git clone https://github.com/zhwangart/hexo-theme-ocean.git themes/ocean 启用目录 theme 中 _config.yml 选择 theme: ocean theme: ocean 更新12$ cd themes/ocean$ git pull 配置默认开启相册与关于菜单，关闭 Gitalk 评论功能，需要的同学 true 就可以了，关于 Gitalk 的使用 过程中遇到各种报错，有同样问题的，或者有兴趣想要了解 Gitalk 可以移步看一看。 Menumenu: 主页: / 归档: /archives 相册: /gallery 关于: /about rss: /atom.xml # Miscellaneous favicon: /favicon.ico brand: /images/hexo.svg # Ocean 主页视频 # 多种格式的视频用于支持不同的浏览器，这里只需要配置好路径，前提是我把视频相关文件统一目录存放。 ocean: overlay: true # 可选，false 则 Ocean 视频下方的笔触式遮盖不显示 path: /images/ocean/ # 视频统一存放路径，格式 mp4/ogg/webm brand: /images/hexo-inverted.svg # 可选，一个小 Logo # 内容 excerpt_link: 阅读全文... share_text: 分享 nav_text: page_prev: 上一页 page_next: 下一页 post_prev: 前一篇 post_next: 后一篇 # fancybox fancybox: true # Local search search_text: 搜索 # Gitalk gitalk: enable: false # 默认关闭评论 开启：true clientID: # 申请 GitHub Application 网页上对应的 Client ID 与 Client Secret 参数 clientSecret: # 同上 repo: # 创建的仓库名称 owner: # Github ID admin: # Github IDOcean 使用了 feathericon 图标库，菜单中的图标定义在“CSS source / css / _partial / navbar.styl”中，可根据需要进行更改或添加。如果你不需要开启相册与关于菜单，需要删除或者注销掉他们的图标，如下边的示例： .nav-item &amp;:nth-child(1) // 主页 .nav-item-link &amp;::before content &apos;\f12f&apos; &amp;:nth-child(2) // 归档 .nav-item-link &amp;::before content &apos;\f12a&apos; //&amp;:nth-child(3) // 相册 // .nav-item-link // &amp;::before // content &apos;\f1a9&apos; //&amp;:nth-child(4) // 关于 // .nav-item-link // &amp;::before // content &apos;\f174&apos;插件 本地搜索 - 使用插件 hexo-generator-search 生成 xml 索引文件。 $ npm install hexo-generator-searchdb --save 然后为 hexo 的配置文件 _config.yml 添加插件配置（注意：不是主题的配置文件，主题配置文件 Ocean 已经配置完成）： # hexo-generator-searchdb@1.0.8 search: path: search.xml field: post format: html content: true RSS - 如果您想启用RSS，还需要 hexo-generate-feed 插件，仅安装即可，Ocean 已经配置完成。 $ npm install hexo-generator-feed --save 文章封面图需要写在 markdown 的 head 部分 title: Post name photos: [ [&quot;img_url&quot;], [&quot;img_url&quot;] ]需要注意的是，这里说的封面图并不是文章配图，文章配图按照 markdown 的语法写就好了！ 相册首先需要创建一个 page ，关于页面也一样需要创建。 $ hexo new page gallery 然后在编辑 markdown 的时候需要写在 head 部分，这种写法可能不是特别特别的好，希望能有更好的方法。 title: Gallery albums: [ [&quot;img_url&quot;,&quot;img_caption&quot;], [&quot;img_url&quot;,&quot;img_caption&quot;] ] ---]]></content>
      <tags>
        <tag>Ocean</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F4a17b156%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Hello</tag>
        <tag>World</tag>
      </tags>
  </entry>
</search>
